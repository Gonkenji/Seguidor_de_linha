// Define os pinos de controle do multiplexador e o pino de entrada analogica
const int ADC_PIN = 28;  // Pino analogico para ler o valor do sensor
const int S0_PIN = 16;   // Pino de controle A (Pino 11 do CD4051B)
const int S1_PIN = 17;   // Pino de controle B (Pino 10 do CD4051B)
const int S2_PIN = 18;   // Pino de controle C (Pino 9 do CD4051B)
const int calibrar = 19; // Bot√£o de calibragem

// Array para armazenar os valores de cada sensor
int sensorValues[8];
int sensorValuesA[8];

int maxmin[8][2]; 

int i;

void calibragem(void);

void setup() {
  // Inicia a comunicacao serial para exibir os dados no Plotter Serial
  Serial.begin(115200);
  delay(1000);
  Serial.println("Pronto para plotar todos os 8 sensores.");

  // Configura os pinos de controle do multiplexador como saida
  pinMode(S0_PIN, OUTPUT);
  pinMode(S1_PIN, OUTPUT);
  pinMode(S2_PIN, OUTPUT);

  // Configura o pino analogico como entrada
  pinMode(ADC_PIN, INPUT);
  
  //calibragem();
}

void loop() {
  // 1. Leitura dos 8 sensores
  for (int channel = 0; channel < 8; channel++) {
    // Seleciona o canal do multiplexador.
    digitalWrite(S0_PIN, (channel >> 0) & 0x01);
    digitalWrite(S1_PIN, (channel >> 1) & 0x01);
    digitalWrite(S2_PIN, (channel >> 2) & 0x01);

    // Aguarda um pequeno tempo para o multiplexador estabilizar
    delay(10);
    
    // Le o valor do sensor no canal selecionado e armazena no array
    sensorValues[channel] = analogRead(ADC_PIN);
  }

  // 2. Impressao dos valores para Plotagem
  
  // Imprime os 8 valores do array na mesma linha
  for (int channel = 0; channel < 8; channel++) {
    Serial.print(sensorValues[channel]*0.05 + sensorValuesA[channel]*0.95);
    sensorValuesA[channel] = sensorValues[channel];
    Serial.print('\t'); // Usa tabulacao para separar os valores
  }

  Serial.println(); // Pula uma linha no final de cada varredura completa

  // Atraso para nao sobrecarregar a porta serial
  delay(50);

  if (digitalRead(calibrar) == 1){
    while (digitalRead(calibrar)){Serial.print(digitalRead(calibrar));} 
      calibragem();
  }
}

void calibragem(){
  for (int channel = 0; channel < 8; channel++) {
      // Seleciona o canal do multiplexador.
      digitalWrite(S0_PIN, (channel >> 0) & 0x01);
      digitalWrite(S1_PIN, (channel >> 1) & 0x01);
      digitalWrite(S2_PIN, (channel >> 2) & 0x01);

      // Aguarda um pequeno tempo para o multiplexador estabilizar
      delay(5);
      
      // Le o valor do sensor no canal selecionado e armazena no array
      maxmin[channel][0] = analogRead(ADC_PIN);
      maxmin[channel][1] = analogRead(ADC_PIN);
    }

  while (i < 5000){
    i = i + 1;
    for (int channel = 0; channel < 8; channel++) {
      // Seleciona o canal do multiplexador.
      digitalWrite(S0_PIN, (channel >> 0) & 0x01);
      digitalWrite(S1_PIN, (channel >> 1) & 0x01);
      digitalWrite(S2_PIN, (channel >> 2) & 0x01);

      // Aguarda um pequeno tempo para o multiplexador estabilizar
      delay(5);
      
      // Le o valor do sensor no canal selecionado e armazena no array
      sensorValues[channel] = analogRead(ADC_PIN);
    }

    for (int channel = 0; channel < 8; channel++) {
      if (sensorValues[channel] < maxmin[channel][0]) 
        maxmin[channel][0] = sensorValues[channel];
      
      else if (sensorValues[channel] > maxmin[channel][1])
        maxmin[channel][1] = sensorValues[channel];

      Serial.print(channel);
      Serial.print(" ");
      Serial.print(maxmin[channel][0]);
      Serial.print(" ");
      Serial.print(maxmin[channel][1]);
      Serial.println(" ");
    }
  }
}
